%==================================================================
% Ini adalah bab 4
% Silahkan edit sesuai kebutuhan, baik menambah atau mengurangi \section, \subsection
%==================================================================

\chapter[HASIL DAN PEMBAHASAN]{\\ HASIL DAN PEMBAHASAN}

\section{Fungsi \textit{benchmark}}
Fungsi-fungsi \textit{benchmark} dari koleksi CECO dirancang untuk menguji dan melakukan \textit{benchmarking} terhadap performa algoritma optimasi. Fungsi-fungsi ini akan digunakan sebagai metrik evaluasi pada bagian selanjutnya untuk mengukur efektivitas dan efisiensi algoritma yang diuji. Untuk rujukan teknis, detail dari setiap fungsi dalam koleksi lengkap CECO telah disajikan pada bagian Lampiran.

\section{Implementasi fungsi \textit{benchmark}}
Fungsi-fungsi \textit{benchmark} yang telah dikumpulkan dan dijelaskan pada bagian sebelumnya kemudian diimplementasikan ke dalam kode program menggunakan bahasa pemrograman Python. Proses implementasi dilakukan dengan memperhatikan struktur modular agar memudahkan pemeliharaan, pengujian, dan pengembangan lebih lanjut. Dalam pengembangannya, beberapa dependensi utama digunakan untuk mendukung fungsionalitas dan keandalan \text{library}.\ \text{Library} NumPy digunakan sebagai basis dalam pengolahan data numerik, mengingat kemampuannya dalam menangani operasi matematis dan array berdimensi tinggi secara efisien. Untuk keperluan pengujian fungsionalitas dan validasi unit dari setiap fungsi \textit{benchmark}, digunakan unittest, modul bawaan Python yang mendukung penerapan prinsip pengujian berbasis test case secara sistematis. Sementara itu, dokumentasi teknis dari \text{library} disusun menggunakan Sphinx, sebuah generator dokumentasi yang mampu menghasilkan dokumentasi dalam berbagai format seperti HTML dan PDF, sehingga memudahkan pengguna dan pengembang dalam memahami struktur serta cara penggunaan \text{library}. Dengan kombinasi alat bantu ini, proses pengembangan \text{library} CECO menjadi lebih terstruktur, terdokumentasi, dan dapat diandalkan untuk digunakan dalam berbagai eksperimen optimasi.

\subsection{\textit{Super Class}}
Kelas induk (\textit{superclass/parent class}) dalam sistem ini diberi nama \textit{Benchmark}, yang berperan sebagai basis untuk seluruh kelas turunan (\textit{child classes}). Kelas ini dirancang dengan pendekatan modular untuk mengintegrasikan berbagai fungsi dasar yang bersifat generik dan sering digunakan berulang kali oleh kelas-kelas turunannya.\\
\subsubsection{Konstruktor}
\textit{Method} ini merupakan konstruktor utama dalam kelas Benchmark. Fungsi utamanya adalah untuk menerima parameter dimensi yang akan digunakan dalam proses evaluasi. Dimensi tersebut menjadi dasar perhitungan di seluruh kelas turunannya dalam implementasi fungsi CEC dan COCO. Syarat dimensi yang dimasukkan harus berupa bilangan bulat positif (\text{integer}) dengan nilai lebih besar dari 0. Selain itu, nilai dimensi tidak diperbolehkan berupa bilangan desimal (\textit{float/double}) maupun bilangan negatif, karena dapat mengganggu proses komputasi dan menghasilkan output yang tidak valid.
\begin{lstlisting}[language=Python, caption=kontruktor kelas benchmark, label=lst:init_benchmark]
    def __init__(self, dimension: int) -> None:
        """
        Initializes the Benchmark class with a rotation matrix and a shift vector.

        Parameters:
            dimension (int): The number of dimensions for the input space. Must be a positive integer.

        Raises:
            ValueError: If `dimension` is not a positive integer.
        """
        if not isinstance(dimension, int):
            raise ValueError("dimension must be integer")
        if dimension < 0:
            raise ValueError("dimension must be positive integer")
        if dimension < 1:
            raise ValueError("dimension cannot be zero")
        self.dimension = dimension
\end{lstlisting}
\subsubsection{cec\_init}
\textit{Method} ini digunakan untuk menerima tiga parameter utama dalam fungsi CEC, yaitu \textit{shift, rotation, dan bias}. Parameter \textit{shift} berupa \textit{array} satu dimensi dengan jumlah elemen yang sesuai dengan nilai dimensi, berfungsi untuk menggeser posisi optimum. \textit{Rotation} berupa matriks dua dimensi berukuran dimensi$\times$dimensi, digunakan untuk merotasi ruang pencarian. \textit{Bias} dapat berupa bilangan bulat atau desimal yang berfungsi sebagai konstanta penambah pada nilai fungsi. Ukuran shift dan rotation harus sesuai dengan dimensi yang telah ditentukan.
\begin{lstlisting}[language=Python, caption=\textit{method} untuk tambahan konstruktor untuk fungsi CEC, label=lst:init_cec]
    def cec_init(self, rotation: np.ndarray, shift: np.ndarray, f_bias: float = 0) -> None:
        """
        Initializes the cec function class with a rotation matrix and a shift vector.

        Parameters:
            rotation (np.ndarray): The rotation matrix.
            shift (np.ndarray): The shift vector.
            f_bias (float): A bias term added to the benchmark function's output. Defaults to 0.
        """
        if not isinstance(rotation, np.ndarray) or rotation.ndim != 2:
            raise ValueError(
                "Rotation matrix must be a non-empty np.ndarray")
        if rotation.shape[0] != self.dimension and shift.shape[0] != self.dimension:
            raise ValueError(
                "rotation dimension and shift dimension does not match dimension")
        elif rotation.shape[0] != self.dimension:
            raise ValueError(
                "rotation dimension does not match dimension")
        elif shift.shape[0] != self.dimension:
            raise ValueError(
                "shift dimension does not match dimension")
        if rotation.shape[0] != rotation.shape[1]:
            raise ValueError("Rotation matrix must be a square matrix")
        if rotation.shape[0] != shift.shape[0]:
            raise ValueError("rotation and shift has different dimensions")
        self.rotation = rotation
        self.shift = shift
        if not isinstance(f_bias, (float, int)):
            raise ValueError(
                "f_bias must be float or int")
        self.f_bias = float(f_bias)
\end{lstlisting}
\subsubsection{create\_diagonal\_matrix}
\textit{Method} ini berfungsi untuk menghasilkan matriks diagonal khusus dengan nilai diagonal berupa pangkat dari parameter alpha ($\alpha $) untuk notasi $\Lambda^{\alpha}$. Matriks tersebut dipakai untuk melakukan transformasi \textit{conditioning} guna memperbesar pengaruh dimensi tertentu dibandingkan dimensi lainnya.
\begin{lstlisting}[language=Python, caption=\textit{method} untuk menghasilkan matriks diagonal, label=lst:init_cec]
    def create_diagonal_matrix(self, alpha: float) -> np.ndarray:
        """
        Creates a diagonal matrix Λ^α, where the diagonal elements are powers of α.

        The diagonal elements are defined as:
            Λ_ii = alpha^(0.5 * (i - 1) / (D - 1)) for i = 1, 2, ..., D,
            where D is the dimension.

        Parameters:
            alpha (float): The base value for the diagonal elements.

        Returns:
            np.ndarray: A diagonal matrix of shape (D, D), where D is the dimension.

        Notes:
            - If the dimension is 1, the matrix is [[1]].
            - If alpha is 0, the matrix is a zero matrix.
        """
        if self.dimension == 1:
            return np.array([[1.0]])

        if alpha == 0:
            return np.zeros((self.dimension, self.dimension))

        exponents = 0.5 * np.arange(self.dimension) / (self.dimension - 1)
        diagonal = alpha ** exponents
        return np.diag(diagonal)
\end{lstlisting}
\subsubsection{generate\_random\_matrix}
\textit{Method} ini berfungsi menghasilkan matriks dua dimensi berukuran dimensi$\times$dimensi secara acak, yang nantinya akan digunakan sebagai nilai matriks $R$ dan $Q$.
\begin{lstlisting}[language=Python, caption=\textit{method} untuk menghasilkan matriks dengan nilai acak, label=lst:init_cec]
    def generate_random_matrix(self, D: int) -> np.ndarray:
        """
        Generates a random matrix with elements drawn from a standard normal distribution.

        Parameters:
            D (int): The size of the matrix (D x D).

        Returns:
            np.ndarray: A random matrix of shape (D, D).
        """
        return np.random.randn(D, D)
\end{lstlisting}
\subsubsection{T\_asy\_beta}
\textit{Method} ini berfungsi untuk melakukan transformasi asimetris pada setiap elemen input. Ini berarti akan mengubah input dengan cara yang tidak seragam, di mana perubahan yang diterapkan pada satu sisi (atau arah) mungkin berbeda dengan sisi lainnya.
\begin{lstlisting}[language=Python, caption=\textit{method} untuk menerapkan transformasi asimetris pada elemen input, label=lst:init_cec]
    def T_asy_beta(self, beta: float, input_vector: np.ndarray) -> np.ndarray:
        """
        Applies the T_asy^beta transformation to a given input vector.

        The transformation is defined as:
            T_asy^beta(x_i) = x_i^(1 + beta * (i / (D - 1)) * sqrt(x_i)) if x_i > 0,
            T_asy^beta(x_i) = x_i otherwise.

        Parameters:
            beta (float): The beta parameter controlling the transformation.
            input_vector (np.ndarray): A vector of real numbers.

        Returns:
            np.ndarray: The transformed vector.

        Notes:
            - If the dimension is 1, the input vector is returned unchanged.
        """
        if self.dimension == 1:
            return input_vector

        i = np.arange(self.dimension)
        mask = input_vector > 0
        exponent = 1 + beta * (i / (self.dimension - 1)
                               ) * np.sqrt(input_vector)
        result = np.where(mask, input_vector ** exponent, input_vector)
        return result
\end{lstlisting}
\subsubsection{T\_osz}
\textit{Method} ini berfungsi untuk menerapkan transformasi non-linear pada elemen input, yang menghasilkan efek osilasi dan ketidakteraturan pada struktur fungsi. Transformasi ini meningkatkan kompleksitas permukaan fungsi, sehingga membuatnya lebih sulit untuk dioptimalkan.
\begin{lstlisting}[language=Python, caption=\textit{method} untuk menerapkan transformasi non-linear pada elemen input, label=lst:init_cec]
    def T_osz(self, input_vector: np.ndarray) -> np.ndarray:
        """
        Applies the T_osz transformation to a given input vector.

        The transformation is defined as:
            T_osz(x_i) = sign(x_i) * exp(x_hat + 0.049 * (sin(c1 * x_hat) + sin(c2 * x_hat))),
            where x_hat = log(|x_i|) if x_i ≠ 0, and 0 otherwise.

        Parameters:
            input_vector (np.ndarray): A vector of real numbers.

        Returns:
            np.ndarray: The transformed vector.

        Notes:
            - The transformation is applied element-wise.
            - If x_i is 0, the result is 0.
        """
        x_hat = np.where(input_vector == 0, 0, np.log(np.abs(input_vector)))
        sign = np.sign(input_vector)
        c1 = np.where(input_vector > 0, 10, 5.5)
        c2 = np.where(input_vector > 0, 7.9, 3.1)
        transformed = np.exp(
            x_hat + 0.049 * (np.sin(c1 * x_hat) + np.sin(c2 * x_hat)))
        return np.where(input_vector == 0, 0, sign * transformed)
\end{lstlisting}
\subsubsection{f\_pen}
\textit{Method} ini berfungsi untuk menerapkan sistem penalti pada elemen input yang melampaui rentang $[-5,5]$. Penalti ini bertujuan mengurangi kemungkinan solusi berada di luar batas tersebut dengan memberikan nilai penalti yang mempengaruhi kualitas solusi. Mekanisme ini berfungsi sebagai pembatas yang mendorong algoritma optimisasi tetap mengeksplorasi dalam rentang yang valid.
\begin{lstlisting}[language=Python, caption=\textit{method} untuk menerapkan penalti pada elemen input, label=lst:init_cec]
    def f_pen(self, x: np.ndarray) -> float:
        """
        Computes the penalty function for a given input vector.

        The penalty function is defined as:
            f_pen(x) = sum(max(0, |x_i| - 5)^2).

        Parameters:
            x (np.ndarray): A vector of real numbers.

        Returns:
            float: The penalty value.
        """
        return np.sum(np.maximum(0, np.abs(x) - 5) ** 2)
\end{lstlisting}
\subsubsection{gram\_schmidt}
\textit{Method} ini berfungsi melakukan proses ortonormalisasi menggunakan algoritma Gram-Schmidt terhadap matriks rotasi beserta elemen-elemen $R$ dan $Q$. Proses ortonormalisasi ini bertujuan untuk memastikan bahwa matriks yang dihasilkan memiliki sifat ortogonal dan ternormalisasi, dimana setiap vektor kolom atau baris saling tegak lurus dan memiliki panjang satuan. Penerapan algoritma Gram-Schmidt ini penting untuk menjaga stabilitas numerik dan validitas matematis dari transformasi rotasi yang akan digunakan dalam fungsi benchmark optimisasi.
\begin{lstlisting}[language=Python, caption=\textit{method} untuk menerapkan penalti pada elemen input, label=lst:init_cec]
    def gram_schmidt(self, matrix: np.ndarray) -> np.ndarray:
        """
        Applies the Gram-Schmidt process to a set of vectors.

        This method orthogonalizes the input vectors (columns of the matrix) and normalizes them to unit length.

        Parameters:
            matrix (np.ndarray): A 2D array where each column is a vector.

        Returns:
            np.ndarray: A 2D array with orthogonal and normalized vectors as columns.

        Notes:
            - If the input vectors are linearly dependent, the output will contain zero vectors for dependent columns.
            - Uses floating-point arithmetic, so results may have small numerical errors.
        """
        matrix = np.array(matrix, dtype=np.float64)
        Q = np.zeros_like(matrix)

        for j in range(matrix.shape[1]):
            v = matrix[:, j]
            for i in range(j):
                v -= np.dot(Q[:, i], v) * Q[:, i]
            norm = np.linalg.norm(v)
            Q[:, j] = v / norm if norm > 1e-14 else 0

        return Q
\end{lstlisting}
\subsection{fungsi CEC dan COCO}
Fungsi-fungsi matematis CEC dan COCO yang telah dikumpulkan dan diidentifikasi sebelumnya diimplementasikan ke dalam sistem dengan pendekatan \textit{Object-Oriented Programming} (OOP) yang ketat. Setiap fungsi CEC dan COCO dikemas dalam kelas terpisah yang mengikuti prinsip \foreignlanguage{english}{\enquote{\textit{one class per file}}}, suatu \textit{best practice} dalam pengembangan perangkat lunak modern yang memberikan beberapa keuntungan penting:
\begin{packed_enum}
	\item Modularitas Tinggi:
    \begin{packed_enum}
      \item Setiap file hanya berisi satu kelas fungsi CEC tertentu
      \item Memisahkan concern dengan jelas antar berbagai fungsi \textit{benchmark}
      \item Memudahkan navigasi dan pemeliharaan kode
    \end{packed_enum}
	\item Struktur Hierarkis:
    \begin{packed_enum}
      \item Seluruh kelas fungsi CEC merupakan turunan (\textit{inheritance}) dari kelas \textit{Benchmark}
      \item Mewarisi semua fungsi dasar dan kemampuan transformasi dari \textit{parent class} 
      \item Mengimplementasikan \textit{interface} yang konsisten untuk semua fungsi \textit{benchmark}
    \end{packed_enum}
	\item Keuntungan Implementasi:
    \begin{packed_enum}
      \item Isolasi perubahan (modifikasi satu fungsi tidak mempengaruhi fungsi lain)
      \item Kemudahan dalam menambahkan fungsi baru tanpa mengganggu sistem yang ada 
      \item Pengelolaan dependensi yang lebih terstruktur
      \item Pengujian unit yang lebih terfokus dan independen
    \end{packed_enum}
	\item Organisasi Kode
	\item Penyimpanan dalam struktur direktori yang jelas
	\item Dokumentasi terintegrasi dalam setiap \textit{file} kelas
\end{packed_enum}
Pendekatan ini memungkinkan:
\begin{packed_enum}
	\item Skalabilitas sistem yang baik untuk penambahan fungsi di masa depan
	\item Kemudahan kolaborasi antar \textit{developer} 
	\item Kemampuan pelacakan perubahan yang lebih baik melalui \textit{version control}
	\item Integrasi yang lebih hasul dengan sistem testing otomatis
\end{packed_enum}
\subsubsection{Konstruktor}
\textit{Method} ini merupakan konstruktor utama dalam kelas fungsi CEC dan COCO. Fungsi utamanya adalah untuk menerima parameter dimensi yang akan digunakan dalam proses evaluasi. Dimensi tersebut menjadi dasar perhitungan di fungsi tersebut. Syarat dimensi yang dimasukkan harus berupa bilangan bulat positif (\text{integer}) dengan nilai lebih besar dari 0. Selain itu, nilai dimensi tidak diperbolehkan berupa bilangan desimal (\textit{float/double}) maupun bilangan negatif, karena dapat mengganggu proses komputasi dan menghasilkan output yang tidak valid. Untuk fungsi CEC menerima parameter \textit{shift} berupa \textit{array} satu dimensi dengan jumlah elemen yang sesuai dengan nilai dimensi, berfungsi untuk menggeser posisi optimum. \textit{Rotation} berupa matriks dua dimensi berukuran dimensi$\times$dimensi, digunakan untuk merotasi ruang pencarian. \textit{Bias} dapat berupa bilangan bulat atau desimal yang berfungsi sebagai konstanta penambah pada nilai fungsi. Ukuran shift dan rotation harus sesuai dengan dimensi yang telah ditentukan.
\begin{lstlisting}[language=Python, caption=kontruktor kelas fungsi CEC, label=lst:init_cec]
    def __init__(self, dimension: int, rotation: np.ndarray, shift: np.ndarray, f_bias: float = 0) -> None:
        """
        Initializes the Sphere class with a rotation matrix and a shift vector.

        Parameters:
            dimension (int): The number of dimensions for the input space. Must be a positive integer.
            rotation (np.ndarray): The rotation matrix for transforming the input vector.
            shift (np.ndarray): The shift vector for adjusting the input vector.
            f_bias (float): A bias term added to the benchmark function's output. Defaults to 0.
        """
        super().__init__(dimension)
        self.cec_init(rotation, shift, f_bias)
\end{lstlisting}
Sementara itu, pada fungsi COCO, beberapa variasi fungsi juga menerima parameter opsional seperti \textit{high conditioning}, \textit{adequate global structure}, dan \textit{ill conditioned} dalam bentuk \textit{boolean}, karena masing-masing fungsi dapat memiliki versi dengan atau tanpa karakteristik tersebut.
\begin{lstlisting}[language=Python, caption=kontruktor kelas fungsi COCO, label=lst:init_cec]
    def __init__(self, dimension: int) -> None:
        """
        Initializes the Sphere function with a given dimension.

        Parameters:
            dimension (int): The number of dimensions for the input space. Must be a positive integer.

        Raises:
            ValueError: If dimension is not a positive integer.
        """
        if not isinstance(dimension, int) or dimension <= 0:
            raise ValueError("Dimension must be a positive integer")
        super().__init__(dimension)
        # Generate a random optimal solution vector x_opt within the range [-5, 5]
        self.x_opt = np.random.uniform(-5, 5, dimension)

        self.f_opt = self.raw(self.x_opt)
\end{lstlisting}
Konstruktor pada fungsi COCO juga menginisialisasi properti $\mathrm{x}^{\text{opt}}$ dan $f_{\text{opt}}$ sebagai titik dan nilai optimum. Selain itu, pada beberapa fungsi, konstruktor turut menginisialisasi properti seperti $R$, $Q$, $\Lambda^{\alpha}$, dan $s_i$ yang digunakan dalam proses transformasi input. Di samping itu, beberapa di fungsi juga menghitung dan menyimpan hasil perhitungan ke dalam variabel di awal untuk menghemat waktu komputasi selama evaluasi fungsi berlangsung.
\begin{lstlisting}[language=Python, caption=kontruktor kelas fungsi COCO, label=lst:init_coco]
    def __init__(self, dimension: int) -> None:
        """
        Initializes the Katsuura function with a given dimension.

        Parameters:
            dimension (int): The number of dimensions for the input space. Must be a positive integer.
            high_conditioning (bool, optional): If `True`, applies a Gram-Schmidt transformation to increase problem conditioning. Defaults to `False`.

        Raises:
            ValueError: If dimension is not a positive integer.
        """
        if not isinstance(dimension, int) or dimension <= 0:
            raise ValueError("Dimension must be a positive integer")
        super().__init__(dimension)
        self.powers_of_two = 2 ** np.arange(1, 33)
        self.inverse_powers = 1 / self.powers_of_two
        self.exponent = 10 / (self.dimension ** 1.2)
        self.scale_factor = 10 / (self.dimension ** 2)
        # Generate a random optimal solution vector x_opt within the range [-5, 5]
        self.x_opt = np.random.uniform(-5, 5, dimension)

        self.f_opt = self.raw(self.x_opt)

        self.R = self.generate_random_matrix(dimension)
        self.R = self.gram_schmidt(self.R)
        self.Q = self.generate_random_matrix(dimension)
        self.Q = self.gram_schmidt(self.Q)
        self.diagonal_matrix = self.create_diagonal_matrix(100)
\end{lstlisting}
\subsubsection{raw}
\textit{Method} ini adalah fungsi dasar yang beroperasi dalam bentuk paling sederhana tanpa melibatkan transformasi tambahan seperti transformasi input, $f_{\text{opt}}$, atau $f_{\text{pen}}$. Fungsi dasar ini berfungsi sebagai komponen inti yang akan dimanfaatkan untuk dua tujuan utama: menghitung nilai $f_{\text{opt}}$ dan melakukan evaluasi pada fungsi-fungsi yang memerlukan transformasi input. Dengan demikian, metode ini berperan sebagai fondasi perhitungan yang kemudian dapat dikembangkan dengan berbagai lapisan transformasi sesuai kebutuhan spesifik fungsi \textit{benchmark}.
\begin{lstlisting}[language=Python, caption=\textit{method raw} fungsi Attractive sector, label=lst:raw_coco]
    def raw(self, x: np.ndarray) -> float:
        """
        Evaluates the Attractive sector function at a given input vector without any shift.

        The function is calculated as:
            f(x) = T_{text{osz}}( sum_{i=1}^{D}( s_iz_i )^2 )^{0.9}

        Parameters:
            x (np.ndarray): A vector of real numbers representing a candidate solution.

        Returns:
            float: The function value at the given input vector.

        Raises:
            ValueError: If the input vector does not match the expected dimension.
        """
        if x.shape[0] != self.dimension:
            raise ValueError(
                f"Input vector must have {self.dimension} elements")

        s = np.where((x * self.x_opt), 10 ** 2, 1)

        result = np.sum((s * x) ** 2)
        return result ** 0.9
\end{lstlisting}
\subsubsection{evaluate}
\textit{Method} ini berfungsi mengevaluasi fungsi pada CEC dan COCO dengan menerapkan berbagai transformasi yang telah didefinisikan. Parameter input yang diterima berupa struktur array yang memiliki jumlah elemen sama dengan nilai dimensi yang telah ditetapkan saat konstruktor kelas diinisialisasi. Konsistensi antara ukuran input dan dimensi yang telah ditentukan merupakan persyaratan wajib untuk memastikan proses evaluasi berjalan dengan benar dan menghasilkan output yang valid.
\begin{lstlisting}[language=Python, caption=\textit{method evaluate} fungsi sphere, label=lst:evaluate_cec]
    def evaluate(self, input_vector: np.ndarray) -> float:
        """
        Evaluates the rotated and shifted sphere function at a given input vector.

        Parameters:
            input_vector (np.ndarray): The input vector [x1, x2, ..., xD].

        Returns:
            float: The result of the sphere function after applying rotation
            and shift.
        """
        # Apply shift and rotation
        shifted_rotated_vector = np.matmul(
            self.rotation, input_vector - self.shift)

        # Calculate the sum of squares
        result = np.sum(shifted_rotated_vector ** 2)

        return result + self.f_bias
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=\textit{method evaluate} fungsi Attractive sector, label=lst:evaluate_coco]
    def evaluate(self, input_vector: np.ndarray) -> float:
        """
        Evaluates the Attractive sector function at a given input vector.

        The function is calculated as:
            f(x) = T_{text{osz}}( sum_{i=1}^{D}( s_iz_i )^2 )^{0.9}+ f_opt

        Parameters:
            input_vector (np.ndarray): A vector of real numbers representing a candidate solution. Must have the same length as the dimension of the Attractive sector function.

        Returns:
            float: The function value at the given input vector.

        Raises:
            ValueError: If the input vector does not match the expected dimension.
        """
        if input_vector.shape[0] != self.dimension:
            raise ValueError(
                f"Input vector must have {self.dimension} elements")

        z = self.Q @ self.diag_matrix @ self.R @ (input_vector - self.x_opt)
        result = self.T_osz(self.raw(z)) + self.f_opt

        return result
\end{lstlisting}
\subsection{Dokumentasi}
Sphinx digunakan sebagai alat dokumentasi standar dalam pengembangan \textit{library} Python CECO. Sistem dokumentasi ini menerapkan pendekatan terintegrasi dimana docstring ditulis langsung dalam \textit{source code}, khususnya pada setiap kelas dan fungsi yang merepresentasikan fungsi \textit{benchmark}. Setiap fungsi \textit{benchmark} memiliki penjelasan komprehensif yang mencakup deskripsi fungsionalitas, parameter yang digunakan, serta detail implementasi yang ditulis dalam kelas yang bersangkutan.

Contoh implementasi docstring dapat dilihat pada kelas Ackley yang ditunjukkan dalam \cref{lst:docstring}. Docstring pada kelas ini memberikan deskripsi lengkap tentang fungsi Ackley sebagai benchmark optimisasi, termasuk formula matematisnya yang kompleks dan multimodal. Dokumentasi juga menjelaskan bahwa kelas ini mewarisi dari kelas Benchmark dan menerapkan transformasi rotasi dan shift pada vektor input sebelum evaluasi fungsi. Setiap atribut seperti dimensi, \textit{rotation}, \textit{shift}, dan $f_\text{bias}$ dijelaskan dengan detail tipe data dan fungsinya.

Metode konstruktor juga didokumentasikan dengan jelas, menjelaskan parameter yang diterima dan validasi yang dilakukan untuk memastikan konsistensi antara matriks rotasi dan vektor \textit{shift}. Sphinx kemudian menggunakan docstring ini untuk secara otomatis menghasilkan dokumentasi dalam berbagai format seperti HTML atau PDF, memastikan dokumentasi selalu terkini dan selaras dengan implementasi kode.
\begin{lstlisting}[language=Python, caption=Dokumentasi menggunakan docstring pada fungsi Ackley, label=lst:docstring]
class Ackley(Benchmark):
    """
    A class representing the Ackley function, which is a benchmark function for optimization.

    The Ackley function is commonly used to test optimization algorithms due to its complex and multi-modal nature. The function is defined as:

    F(X) = -20 * exp(-0.2 * sqrt((1/D) * sum_{i=1}^D x_i^2)) - exp((1/D) * sum_{i=1}^D cos(2 * pi * x_i)) + 20 + e,

    where D is the dimensionality of the problem, and e is Euler's number (~2.71828).

    The class inherits from the `Benchmark` class and applies rotation and shift transformations to the input vector before evaluating the function.

    Attributes:
        dimension (int): The number of dimensions for the input space. Must be a positive integer.
        rotation (np.ndarray): A rotation matrix for transforming the input vector.
        shift (np.ndarray): A shift vector for adjusting the input vector.
        f_bias (float): A bias term added to the benchmark function's output. Defaults to 0.
    """

    def __init__(self, dimension: int, rotation: np.ndarray, shift: np.ndarray, f_bias: float = 0) -> None:
        """
        Initializes the Ackley class with a rotation matrix and a shift vector.

        Ensures that the rotation matrix and shift vector have the same length. If their lengths do not match, a ValueError is raised.

        Parameters:
            dimension (int): The number of dimensions for the input space. Must be a positive integer.
            rotation (np.ndarray): The rotation matrix for transforming the input vector.
            shift (np.ndarray): The shift vector for adjusting the input vector.
            f_bias (float): A bias term added to the benchmark function's output. Defaults to 0.
        """
        super().__init__(dimension)
        self.cec_init(rotation, shift, f_bias)
\end{lstlisting}

Untuk dokumentasi yang tidak terkait langsung dengan fungsi benchmark seperti panduan instalasi, struktur direktori, dan contoh penggunaan \textit{library} CECO menggunakan format reStructuredText (.rst). Contoh \cref{lst:rst} menunjukkan bagaimana modul-modul dalam \textit{package} ceco.cec didokumentasikan menggunakan direktif \textit{automodule} yang secara otomatis mengekstrak \textit{members}, \textit{members} yang tidak memiliki dokumentasi docstring atau doc-comment, dan hierarki pewarisan dari setiap modul.
\begin{lstlisting}[caption=Dokumentasi dengan \textit{reStructuredText}, label=lst:rst]
ceco.cec package
================

Conference of Evolutional Computation (CEC) benchmark functions.
----------------------------------------------------------------

ceco.cec.ackley module
----------------------
.. automodule:: ceco.cec.ackley
   :members:
   :undoc-members:
   :show-inheritance:

ceco.cec.bent_cigar module
--------------------------
.. automodule:: ceco.cec.bent_cigar
   :members:
   :undoc-members:
   :show-inheritance:
\end{lstlisting}
Pemisahan antara dokumentasi teknis internal berbasis docstring dan dokumentasi umum berbasis\ .rst menciptakan sistem dokumentasi yang komprehensif dan terstruktur. Pendekatan ini memungkinkan \textit{library} CECO menyediakan informasi yang mudah diakses baik untuk pengguna pemula maupun pengembang berpengalaman, sehingga meningkatkan kemudahan adopsi dan mempercepat integrasi dalam berbagai proyek penelitian optimisasi.

\section{\textit{Benchmarking}}
Dalam proses benchmarking menggunakan 6 fungsi dari dua kategori utama: fungsi unimodal dan multimodal. Masing-masing kategori diwakili oleh tiga fungsi, untuk multimodal mencakup Ackley, Griewank, dan Weierstrass, sedangkan untuk unimodal meliputi Sphere, Schwefel 1.2 problem, dan Discus. Fungsi-fungsi ini memiliki berbagai tingkat kompleksitas dengan dimensi yang bervariasi, mulai dari 1, 2, 5, 10, 20, 25, 50, 100, 200, hingga 500. Keberagaman dimensi ini memungkinkan evaluasi algoritma dalam berbagai skenario optimasi, baik yang sederhana maupun kompleks.

Untuk melakukan benchmarking, digunakan 3 algoritma optimasi, yaitu \textit{Komodo Mlipir Algorithm} (KMA) \citep{Suyanto_2022}, \textit{Elephant Herding Optimization} (EHO) \citep{Wang_2015}, \textit{Particle Swarm Optimization} (PSO) \citep{Kennedy_1995}. KMA terinspirasi dari pergerakan komodo dalam berburu mangsanya, EHO didasarkan pada perilaku sosial kawanan gajah dalam mencari sumber daya, dan PSO terinspirasi dari strategi pencarian makan pada kawanan burung. Ketiga algoritma ini dipilih untuk menguji efektivitas dalam menyelesaikan permasalahan optimasi pada berbagai jenis fungsi \textit{benchmark} yang telah ditentukan.

\subsection{Pengaturan Parameter}
Pada algoritma \textit{Komodo Mlipir Algorithm} (KMA), jumlah populasi awal yang digunakan adalah 5 individu, dengan batas minimum populasi tetap 5 dan batas maksimum 200, serta mengalami perubahan populasi secara bertahap sebesar 5 individu. Selain itu, algoritma ini memiliki parameter tingkat mlipir untuk komodo kecil sebesar 0.5, sementara porsi komodo besar juga ditetapkan pada nilai yang sama, yaitu 0.5.

Algoritma \textit{Elephant Herding Optimization} (EHO) menggunakan populasi 50 individu, yang dikelompokkan ke dalam 5 suku. Parameter tambahan dalam algoritma ini meliputi alpha dengan nilai 0.1 dan beta sebesar 0.1, yang mengatur dinamika eksplorasi dan eksploitasi selama proses optimasi berlangsung.

Algoritma \textit{Particle Swarm Optimization} (PSO) menggunakan populasi 50 individu. Konfigurasi parameter yang diterapkan meliputi bobot inersia ($w$) dengan nilai 0.5, serta koefisien akselerasi personal ($c1$) dan sosial ($c2$) yang masing-masing ditetapkan pada nilai 2.

Baik KMA, EHO, dan PSO melaksanakan proses pencarian solusi dengan batas maksimum sebanyak 100 iterasi. Dengan demikian, evaluasi performa ketiga algoritma dilakukan secara adil dalam jumlah perulangan yang sama, sehingga hasil yang diperoleh dapat dibandingkan secara setara. Selain itu, untuk memastikan konsistensi dan reliabilitas hasil, setiap algoritma dijalankan sebanyak 30 kali pengujian terpisah. Pendekatan ini bertujuan untuk mengurangi pengaruh faktor kebetulan atau kondisi awal yang bersifat acak, serta memperoleh gambaran performa algoritma yang lebih akurat dan representatif. Detail lengkap mengenai konfigurasi parameter yang digunakan pada masing-masing algoritma dapat ditemukan dalam \cref{tab:pengaturan-parameter}

% Please add the following required packages to your document preamble:
% \usepackage{multirow[t]}
\begin{table}[h!]
\centering
\caption{pengaturan parameter}
\label{tab:pengaturan-parameter}
\begin{tabular}{|l|l|l|}
\hline
algoritma            & parameter                 & nilai \\ \hline
\multirow[t]{7}{*}{KMA} & populasi awal             & 5     \\ \cline{2-3} 
                     & populasi minimal          & 5     \\ \cline{2-3} 
                     & populasi maksimal         & 200   \\ \cline{2-3} 
                     & tingkat mlipir            & 0.5   \\ \cline{2-3} 
                     & porsi komodo jantan besar & 0.5   \\ \cline{2-3} 
                     & perubahan populasi        & 5     \\ \cline{2-3} 
                     & maksimum iterasi          & 100   \\ \hline
\multirow[t]{5}{*}{EHO} & populasi                  & 50    \\ \cline{2-3} 
                     & jumlah suku               & 5     \\ \cline{2-3} 
                     & alpha                     & 0.5   \\ \cline{2-3} 
                     & beta                      & 0.1   \\ \cline{2-3} 
                     & maksimum iterasi          & 100   \\ \hline
\multirow[t]{5}{*}{PSO} & populasi                  & 50    \\ \cline{2-3} 
                     & $w$               & 0.5     \\ \cline{2-3} 
                     & $c1$                     & 2   \\ \cline{2-3} 
                     & $c2$                      & 2   \\ \cline{2-3} 
                     & maksimum iterasi          & 100   \\ \hline
\end{tabular}
\end{table}

\subsection{Hasil \textit{Benchmark}}
Hasil pengujian terhadap \textit{Elephant Herding Optimization} (EHO), \textit{Komodo Mlipir Algorithm} (KMA), \textit{Particle Swarm Optimization} pada 6 fungsi benchmark yang meliputi unimodal dan multimodal dengan berbagai dimensi mengungkap karakteristik kinerja yang berbeda. PSO menunjukkan kinerja sangat baik pada skenario berdimensi rendah, dimensi 1-2 (\cref{tab:pso-result}, \cref{tab:summary-result}, \cref{fig:graph_ackley}, \cref{fig:graph_discus}, \cref{fig:graph_griewank}, \cref{fig:graph_schwefel_1_2}, \cref{fig:graph_sphere}, \cref{fig:graph_weierstrass}), khususnya untuk fungsi unimodal dan multimodal ringan, dengan pencapaian error rata-rata rendah dan konsistensi tinggi. Namun, kinerjanya menurun signifikan pada lanskap berdimensi tinggi atau multimodal kompleks, terutama pada fungsi seperti Schwefel 1.2 dan Discus (\cref{tab:pso-result}, \cref{fig:graph_schwefel_1_2},  \cref{fig:graph_discus}), di mana hasilnya menjadi sangat tidak stabil dan error rata-ratanya meningkat secara eksponensial.

Sebaliknya, KMA menunjukkan ketangguhan dan skalabilitas yang kuat, secara konsisten memberikan kinerja unggul baik pada fungsi unimodal maupun multimodal di semua dimensi (\cref{tab:kma-result}, \cref{tab:summary-result}, \cref{fig:graph_ackley}, \cref{fig:graph_discus}, \cref{fig:graph_griewank}, \cref{fig:graph_schwefel_1_2}, \cref{fig:graph_sphere}, \cref{fig:graph_weierstrass}). Algoritma ini unggul terutama pada lanskap unimodal yang halus seperti Sphere dan Griewank (\cref{tab:kma-result}, \cref{fig:graph_sphere}, \cref{fig:graph_griewank}), serta tetap andal pada fungsi kompleks, mempertahankan deviasi standar dan error rata-rata rendah bahkan pada kasus berdimensi tinggi.

Sementara itu, EHO, meskipun sedikit kurang konsisten dibandingkan KMA, menunjukkan kinerja superior pada fungsi multimodal bergerigi seperti Ackley dan Weierstrass (\cref{tab:eho-result}, \cref{tab:summary-result}, \cref{fig:graph_ackley}, \cref{fig:graph_discus}, \cref{fig:graph_griewank}, \cref{fig:graph_schwefel_1_2}, \cref{fig:graph_sphere}, \cref{fig:graph_weierstrass}), terutama seiring meningkatnya dimensi. EHO sering melampaui PSO dan sesekali mengungguli KMA (\cref{tab:eho-result}) dalam menangani lanskap menyesatkan (\textit{deceptive landscapes}) fungsi-fungsi tersebut berkat kemampuan eksplorasinya yang kuat.

Secara keseluruhan, PSO sangat cocok untuk masalah sederhana dan berdimensi rendah, sedangkan KMA terbukti paling seimbang dan andal di berbagai tipe lanskap dan dimensi. EHO muncul sebagai pesaing tangguh pada lanskap multimodal dan kompleks di mana eksplorasi efektif menjadi kritis. Hasil \textit{benchmarking} ini menunjukkan pentingnya menyesuaikan penggunaan algoritma berdasarkan sifat lanskap fungsi dan kompleksitas dimensi masalah dalam masalah optimasi dunia nyata. Informasi detail mengenai kinerja masing-masing algoritma tersedia pada tabel yang terpisah: hasil EHO dapat dilihat pada \cref{tab:eho-result}, hasil KMA pada \cref{tab:kma-result}, dan hasil PSO pada \cref{tab:pso-result}. Adapun ringkasan komprehensif dari seluruh hasil \textit{benchmarking} disajikan dalam \cref{tab:summary-result}.

\begin{longtable}[c]{|p{3.5cm}|l|l|l|l|l|}
\caption{hasil \textit{benchmark} EHO}
\label{tab:eho-result}\\
\hline
function                               & dimension & avg      & best     & worst    & std      \\ \hline
\endfirsthead
%
\endhead
%
\multirow[t]{10}{*}{ackley}               & 1         & 5,20E-08 & 7,57E-13 & 1,55E-06 & 2,79E-07 \\ \cline{2-6} 
                                       & 2         & 7,40E-04 & 1,19E-07 & 1,22E-02 & 2,38E-03 \\ \cline{2-6} 
                                       & 5         & 1,96E-02 & 2,62E-03 & 1,68E-01 & 2,90E-02 \\ \cline{2-6} 
                                       & 10        & 3,99E-02 & 6,08E-03 & 9,37E-02 & 2,58E-02 \\ \cline{2-6} 
                                       & 20        & 5,53E-02 & 5,96E-03 & 1,43E-01 & 3,68E-02 \\ \cline{2-6} 
                                       & 25        & 4,69E-02 & 8,60E-03 & 1,83E-01 & 3,72E-02 \\ \cline{2-6} 
                                       & 50        & 6,41E-02 & 1,62E-02 & 1,97E-01 & 4,26E-02 \\ \cline{2-6} 
                                       & 100       & 4,83E-02 & 6,30E-03 & 1,28E-01 & 2,56E-02 \\ \cline{2-6} 
                                       & 200       & 5,25E-02 & 7,00E-03 & 1,29E-01 & 3,33E-02 \\ \cline{2-6} 
                                       & 500       & 6,33E-02 & 7,24E-03 & 1,65E-01 & 3,15E-02 \\ \hline
\multirow[t]{10}{*}{discus}               & 1         & 1,19E-07 & 1,50E-20 & 3,56E-06 & 6,39E-07 \\ \cline{2-6} 
                                       & 2         & 1,49E-01 & 3,80E-05 & 8,72E-01 & 2,39E-01 \\ \cline{2-6} 
                                       & 5         & 3,20E-01 & 2,30E-03 & 2,73E+00 & 5,50E-01 \\ \cline{2-6} 
                                       & 10        & 5,87E-01 & 7,04E-03 & 2,89E+00 & 7,67E-01 \\ \cline{2-6} 
                                       & 20        & 7,98E-01 & 1,74E-02 & 1,12E+01 & 2,00E+00 \\ \cline{2-6} 
                                       & 25        & 4,62E-01 & 8,74E-03 & 2,47E+00 & 5,28E-01 \\ \cline{2-6} 
                                       & 50        & 9,47E-01 & 8,01E-03 & 4,56E+00 & 1,06E+00 \\ \cline{2-6} 
                                       & 100       & 4,75E-01 & 5,41E-02 & 3,18E+00 & 5,78E-01 \\ \cline{2-6} 
                                       & 200       & 9,15E-01 & 3,81E-02 & 3,56E+00 & 8,74E-01 \\ \cline{2-6} 
                                       & 500       & 8,85E-01 & 6,59E-03 & 3,83E+00 & 8,37E-01 \\ \hline
\multirow[t]{10}{*}{griewank}             & 1         & 3,29E-04 & 0.00E+00 & 9,86E-03 & 1,77E-03 \\ \cline{2-6} 
                                       & 2         & 6,28E-03 & 8,56E-14 & 2,71E-02 & 7,34E-03 \\ \cline{2-6} 
                                       & 5         & 7,34E-03 & 4,33E-07 & 2,19E-01 & 3,94E-02 \\ \cline{2-6} 
                                       & 10        & 2,68E-05 & 1,12E-06 & 1,10E-04 & 2,97E-05 \\ \cline{2-6} 
                                       & 20        & 1,97E-04 & 2,28E-06 & 1,89E-03 & 3,64E-04 \\ \cline{2-6} 
                                       & 25        & 1,69E-04 & 1,83E-06 & 1,68E-03 & 3,75E-04 \\ \cline{2-6} 
                                       & 50        & 2,38E-04 & 6,62E-06 & 1,09E-03 & 2,54E-04 \\ \cline{2-6} 
                                       & 100       & 3,48E-04 & 4,41E-06 & 1,76E-03 & 4,45E-04 \\ \cline{2-6} 
                                       & 200       & 3,26E-04 & 7,36E-06 & 2,53E-03 & 4,95E-04 \\ \cline{2-6} 
                                       & 500       & 6,01E-04 & 9,61E-06 & 2,52E-03 & 5,42E-04 \\ \hline
\multirow[t]{10}{*}{schwefel 1.2 problem} & 1         & 8,48E-21 & 3,96E-26 & 1,27E-19 & 3,15E-20 \\ \cline{2-6} 
                                       & 2         & 1,92E-07 & 9,70E-16 & 2,68E-06 & 6,21E-07 \\ \cline{2-6} 
                                       & 5         & 1,44E-04 & 5,57E-06 & 1,05E-03 & 2,11E-04 \\ \cline{2-6} 
                                       & 10        & 1,33E-03 & 5,28E-05 & 4,70E-03 & 1,40E-03 \\ \cline{2-6} 
                                       & 20        & 1,05E-02 & 1,13E-04 & 6,50E-02 & 1,37E-02 \\ \cline{2-6} 
                                       & 25        & 1,40E-02 & 3,16E-04 & 4,87E-02 & 1,40E-02 \\ \cline{2-6} 
                                       & 50        & 2,32E-01 & 8,68E-04 & 4,24E+00 & 7,51E-01 \\ \cline{2-6} 
                                       & 100       & 1,70E+00 & 7,07E-02 & 1,17E+01 & 2,47E+00 \\ \cline{2-6} 
                                       & 200       & 6,77E+00 & 1,59E-01 & 2,49E+01 & 6,66E+00 \\ \cline{2-6} 
                                       & 500       & 6,89E+01 & 3,56E+00 & 2,58E+02 & 7,07E+01 \\ \hline
\multirow[t]{10}{*}{sphere}               & 1         & 3,29E-19 & 6,87E-27 & 9,61E-18 & 1,72E-18 \\ \cline{2-6} 
                                       & 2         & 8,78E-08 & 8,00E-17 & 2,50E-06 & 4,49E-07 \\ \cline{2-6} 
                                       & 5         & 5,03E-05 & 6,69E-07 & 2,50E-04 & 6,27E-05 \\ \cline{2-6} 
                                       & 10        & 3,96E-04 & 1,58E-05 & 3,13E-03 & 6,50E-04 \\ \cline{2-6} 
                                       & 20        & 1,52E-03 & 4,41E-05 & 1,41E-02 & 2,72E-03 \\ \cline{2-6} 
                                       & 25        & 2,60E-03 & 8,94E-05 & 9,02E-03 & 2,37E-03 \\ \cline{2-6} 
                                       & 50        & 6,83E-03 & 1,19E-04 & 3,15E-02 & 7,26E-03 \\ \cline{2-6} 
                                       & 100       & 2,81E-02 & 1,04E-03 & 7,50E-02 & 2,41E-02 \\ \cline{2-6} 
                                       & 200       & 3,48E-02 & 1,31E-03 & 1,99E-01 & 4,15E-02 \\ \cline{2-6} 
                                       & 500       & 8,83E-02 & 1,08E-02 & 3,20E-01 & 7,46E-02 \\ \hline
\multirow[t]{10}{*}{weierstrass}          & 1         & 4,02E-04 & 5,96E-12 & 5,42E-03 & 1,20E-03 \\ \cline{2-6} 
                                       & 2         & 1,07E-01 & 2,47E-05 & 5,88E-01 & 1,60E-01 \\ \cline{2-6} 
                                       & 5         & 2,89E+00 & 7,31E-01 & 4,53E+00 & 7,94E-01 \\ \cline{2-6} 
                                       & 10        & 9,44E+00 & 6,70E+00 & 1,19E+01 & 1,30E+00 \\ \cline{2-6} 
                                       & 20        & 2,47E+01 & 2,09E+01 & 2,72E+01 & 1,81E+00 \\ \cline{2-6} 
                                       & 25        & 3,31E+01 & 2,96E+01 & 3,76E+01 & 2,01E+00 \\ \cline{2-6} 
                                       & 50        & 7,62E+01 & 7,09E+01 & 8,08E+01 & 2,98E+00 \\ \cline{2-6} 
                                       & 100       & 1,67E+02 & 1,53E+02 & 1,76E+02 & 4,51E+00 \\ \cline{2-6} 
                                       & 200       & 3,53E+02 & 3,35E+02 & 3,64E+02 & 6,55E+00 \\ \cline{2-6} 
                                       & 500       & 8,96E+02 & 4,42E+01 & 9,47E+02 & 1,58E+02 \\ \hline
\end{longtable}

% |p{3cm}|l|p{3cm}|p{3cm}|p{3cm}|p{3cm}|
\begin{longtable}[c]{|p{3.5cm}|l|l|l|l|l|}
\caption{hasil \textit{benchmark} KMA}
\label{tab:kma-result}\\
\hline
function                               & dimension & avg      & best     & worst    & std      \\ \hline
\endfirsthead
%
\endhead
%
\multirow[t]{10}{*}{ackley}               & 1         & 4,43E-04 & 4,44E-16 & 9,44E-03 & 1,69E-03 \\ \cline{2-6} 
                                       & 2         & 9,62E-03 & 3,87E-06 & 1,11E-01 & 2,18E-02 \\ \cline{2-6} 
                                       & 5         & 1,07E-01 & 9,50E-06 & 2,84E+00 & 5,08E-01 \\ \cline{2-6} 
                                       & 10        & 4,20E-02 & 4,44E-16 & 6,31E-01 & 1,23E-01 \\ \cline{2-6} 
                                       & 20        & 1,12E+00 & 4,52E-05 & 2,00E+01 & 4,04E+00 \\ \cline{2-6} 
                                       & 25        & 1,06E+00 & 4,42E-05 & 2,00E+01 & 3,72E+00 \\ \cline{2-6} 
                                       & 50        & 2,33E-01 & 4,86E-06 & 6,55E+00 & 1,17E+00 \\ \cline{2-6} 
                                       & 100       & 1,60E+00 & 1,30E-04 & 2,00E+01 & 4,96E+00 \\ \cline{2-6} 
                                       & 200       & 1,97E+00 & 3,30E-05 & 2,00E+01 & 5,37E+00 \\ \cline{2-6} 
                                       & 500       & 1,93E+00 & 2,00E-04 & 2,00E+01 & 4,98E+00 \\ \hline
\multirow[t]{10}{*}{discus}               & 1         & 2,84E-02 & 0.00E+00 & 5,38E-01 & 1,02E-01 \\ \cline{2-6} 
                                       & 2         & 3,00E-01 & 2,06E-06 & 6,86E+00 & 1,24E+00 \\ \cline{2-6} 
                                       & 5         & 4,76E-01 & 3,95E-05 & 4,79E+00 & 1,00E+00 \\ \cline{2-6} 
                                       & 10        & 8,05E-01 & 2,66E-07 & 1,78E+01 & 3,19E+00 \\ \cline{2-6} 
                                       & 20        & 4,13E-01 & 2,80E-09 & 3,83E+00 & 1,03E+00 \\ \cline{2-6} 
                                       & 25        & 2,50E+00 & 3,55E-09 & 3,88E+01 & 7,15E+00 \\ \cline{2-6} 
                                       & 50        & 7,11E-01 & 4,81E-08 & 8,13E+00 & 1,71E+00 \\ \cline{2-6} 
                                       & 100       & 1,01E+00 & 9,55E-07 & 1,05E+01 & 2,47E+00 \\ \cline{2-6} 
                                       & 200       & 8,41E-01 & 8,15E-06 & 2,24E+01 & 4,02E+00 \\ \cline{2-6} 
                                       & 500       & 4,13E-01 & 1,03E-05 & 4,77E+00 & 1,09E+00 \\ \hline
\multirow[t]{10}{*}{griewank}             & 1         & 2,79E-03 & 0.00E+00 & 1,69E-02 & 4,76E-03 \\ \cline{2-6} 
                                       & 2         & 3,53E-02 & 3,18E-08 & 1,68E-01 & 3,83E-02 \\ \cline{2-6} 
                                       & 5         & 1,93E-01 & 3,60E-09 & 7,79E-01 & 2,31E-01 \\ \cline{2-6} 
                                       & 10        & 7,40E-02 & 1,29E-11 & 8,18E-01 & 2,23E-01 \\ \cline{2-6} 
                                       & 20        & 1,43E-05 & 6,62E-11 & 1,77E-04 & 3,76E-05 \\ \cline{2-6} 
                                       & 25        & 3,70E-06 & 1,47E-11 & 5,36E-05 & 1,03E-05 \\ \cline{2-6} 
                                       & 50        & 2,08E-05 & 6,12E-11 & 5,10E-04 & 9,14E-05 \\ \cline{2-6} 
                                       & 100       & 2,80E-05 & 1,34E-10 & 4,67E-04 & 8,94E-05 \\ \cline{2-6} 
                                       & 200       & 8,10E-06 & 1,01E-09 & 1,18E-04 & 2,25E-05 \\ \cline{2-6} 
                                       & 500       & 9,16E-05 & 4,15E-11 & 1,24E-03 & 2,76E-04 \\ \hline
\multirow[t]{10}{*}{schwefel 1.2 problem} & 1         & 9,38E-08 & 0.00E+00 & 2,43E-06 & 4,38E-07 \\ \cline{2-6} 
                                       & 2         & 1,85E-05 & 2,24E-11 & 4,15E-04 & 7,42E-05 \\ \cline{2-6} 
                                       & 5         & 8,14E-05 & 9,77E-10 & 6,67E-04 & 1,78E-04 \\ \cline{2-6} 
                                       & 10        & 2,15E-03 & 5,38E-09 & 3,70E-02 & 6,74E-03 \\ \cline{2-6} 
                                       & 20        & 5,77E-03 & 1,35E-09 & 5,57E-02 & 1,27E-02 \\ \cline{2-6} 
                                       & 25        & 5,82E-03 & 7,46E-08 & 6,18E-02 & 1,32E-02 \\ \cline{2-6} 
                                       & 50        & 9,27E-02 & 1,57E-07 & 1,30E+00 & 2,68E-01 \\ \cline{2-6} 
                                       & 100       & 9,06E-01 & 5,51E-06 & 1,28E+01 & 2,44E+00 \\ \cline{2-6} 
                                       & 200       & 1,21E+01 & 1,23E-04 & 2,74E+02 & 4,91E+01 \\ \cline{2-6} 
                                       & 500       & 1,94E+01 & 3,44E-06 & 3,83E+02 & 6,90E+01 \\ \hline
\multirow[t]{10}{*}{sphere}               & 1         & 4,28E-09 & 0.00E+00 & 1,05E-07 & 1,87E-08 \\ \cline{2-6} 
                                       & 2         & 3,38E-05 & 2,43E-10 & 7,26E-04 & 1,35E-04 \\ \cline{2-6} 
                                       & 5         & 9,31E-06 & 3,13E-11 & 9,17E-05 & 2,06E-05 \\ \cline{2-6} 
                                       & 10        & 3,71E-04 & 5,78E-12 & 8,94E-03 & 1,62E-03 \\ \cline{2-6} 
                                       & 20        & 8,01E-05 & 7,46E-10 & 1,20E-03 & 2,36E-04 \\ \cline{2-6} 
                                       & 25        & 2,03E-04 & 2,73E-09 & 4,80E-03 & 8,57E-04 \\ \cline{2-6} 
                                       & 50        & 2,82E-04 & 2,27E-09 & 2,03E-03 & 5,71E-04 \\ \cline{2-6} 
                                       & 100       & 8,67E-04 & 1,44E-08 & 8,95E-03 & 1,80E-03 \\ \cline{2-6} 
                                       & 200       & 3,76E-03 & 1,75E-08 & 5,87E-02 & 1,30E-02 \\ \cline{2-6} 
                                       & 500       & 9,55E-04 & 1,25E-08 & 1,60E-02 & 2,96E-03 \\ \hline
\multirow[t]{10}{*}{weierstrass}          & 1         & 2,15E-02 & 0.00E+00 & 1,28E-01 & 3,36E-02 \\ \cline{2-6} 
                                       & 2         & 1,69E-01 & 0.00E+00 & 1,34E+00 & 3,06E-01 \\ \cline{2-6} 
                                       & 5         & 1,05E+00 & 0.00E+00 & 5,85E+00 & 1,92E+00 \\ \cline{2-6} 
                                       & 10        & 4,63E+00 & 3,55E-15 & 1,32E+01 & 5,51E+00 \\ \cline{2-6} 
                                       & 20        & 2,69E+00 & 6,39E-14 & 2,98E+01 & 7,35E+00 \\ \cline{2-6} 
                                       & 25        & 2,99E+00 & 1,42E-14 & 3,35E+01 & 8,74E+00 \\ \cline{2-6} 
                                       & 50        & 2,82E+00 & 1,42E-14 & 7,96E+01 & 1,43E+01 \\ \cline{2-6} 
                                       & 100       & 9,68E+00 & 0.00E+00 & 1,69E+02 & 3,22E+01 \\ \cline{2-6} 
                                       & 200       & 1,71E-01 & 6,82E-13 & 2,42E+00 & 4,93E-01 \\ \cline{2-6} 
                                       & 500       & 3,03E-01 & 2,50E-12 & 3,50E+00 & 7,27E-01 \\ \hline
\end{longtable}

\begin{longtable}[c]{|p{3.5cm}|l|l|l|l|l|}
\caption{hasil \textit{benchmark} PSO}
\label{tab:pso-result}\\
\hline
function                               & dimension & avg      & best     & worst    & std      \\ \hline
\endfirsthead
%
\endhead
%
\multirow[t]{10}{*}{ackley}               & 1         & 9,30E-11 & 1,43E-13 & 8,49E-10 & 1,74E-10 \\ \cline{2-6} 
                                       & 2         & 1,20E-07 & 4,50E-09 & 4,23E-07 & 1,11E-07 \\ \cline{2-6} 
                                       & 5         & 1,54E+01 & 2,05E-03 & 2,02E+01 & 8,43E+00 \\ \cline{2-6} 
                                       & 10        & 2,05E+01 & 2,03E+01 & 2,07E+01 & 1,31E-01 \\ \cline{2-6} 
                                       & 20        & 2,08E+01 & 2,06E+01 & 2,11E+01 & 1,14E-01 \\ \cline{2-6} 
                                       & 25        & 2,10E+01 & 2,07E+01 & 2,12E+01 & 1,13E-01 \\ \cline{2-6} 
                                       & 50        & 2,12E+01 & 2,10E+01 & 2,13E+01 & 6,85E-02 \\ \cline{2-6} 
                                       & 100       & 2,14E+01 & 2,13E+01 & 2,14E+01 & 5,06E-02 \\ \cline{2-6} 
                                       & 200       & 2,15E+01 & 2,14E+01 & 2,15E+01 & 4,04E-02 \\ \cline{2-6} 
                                       & 500       & 2,16E+01 & 2,15E+01 & 2,16E+01 & 1,64E-02 \\ \hline
\multirow[t]{10}{*}{discus}               & 1         & 3,26E-15 & 1,75E-21 & 9,24E-14 & 1,66E-14 \\ \cline{2-6} 
                                       & 2         & 1,15E-10 & 2,53E-14 & 9,70E-10 & 2,42E-10 \\ \cline{2-6} 
                                       & 5         & 5,06E-05 & 1,60E-06 & 4,85E-04 & 9,09E-05 \\ \cline{2-6} 
                                       & 10        & 7,87E-01 & 1,85E-02 & 4,44E+00 & 1,12E+00 \\ \cline{2-6} 
                                       & 20        & 8,05E+02 & 7,73E+01 & 3,26E+03 & 7,78E+02 \\ \cline{2-6} 
                                       & 25        & 2,67E+03 & 3,38E+02 & 6,21E+03 & 1,43E+03 \\ \cline{2-6} 
                                       & 50        & 4,90E+04 & 2,18E+04 & 9,61E+04 & 2,18E+04 \\ \cline{2-6} 
                                       & 100       & 2,47E+05 & 1,47E+05 & 4,64E+05 & 8,34E+04 \\ \cline{2-6} 
                                       & 200       & 8,31E+05 & 4,64E+05 & 1,62E+06 & 2,74E+05 \\ \cline{2-6} 
                                       & 500       & 2,05E+06 & 1,26E+06 & 3,34E+06 & 5,23E+05 \\ \hline
\multirow[t]{10}{*}{griewank}             & 1         & 3,70E-18 & 0.00E+00 & 1,11E-16 & 1,99E-17 \\ \cline{2-6} 
                                       & 2         & 4,11E-03 & 5,55E-16 & 9,86E-03 & 3,89E-03 \\ \cline{2-6} 
                                       & 5         & 6,65E-02 & 9,86E-03 & 1,26E-01 & 3,05E-02 \\ \cline{2-6} 
                                       & 10        & 2,57E-01 & 3,15E-02 & 6,67E-01 & 1,65E-01 \\ \cline{2-6} 
                                       & 20        & 9,61E-01 & 4,17E-01 & 1,06E+00 & 1,45E-01 \\ \cline{2-6} 
                                       & 25        & 1,18E+00 & 1,06E+00 & 1,55E+00 & 1,16E-01 \\ \cline{2-6} 
                                       & 50        & 9,58E+00 & 5,06E+00 & 1,91E+01 & 3,16E+00 \\ \cline{2-6} 
                                       & 100       & 6,09E+01 & 4,39E+01 & 7,39E+01 & 8,30E+00 \\ \cline{2-6} 
                                       & 200       & 1,44E+02 & 1,32E+02 & 1,53E+02 & 4,63E+00 \\ \cline{2-6} 
                                       & 500       & 3,81E+02 & 3,58E+02 & 3,94E+02 & 8,70E+00 \\ \hline
\multirow[t]{10}{*}{schwefel 1.2 problem} & 1         & 4,36E-21 & 1,54E-27 & 4,93E-20 & 1,13E-20 \\ \cline{2-6} 
                                       & 2         & 4,05E-14 & 3,14E-17 & 4,49E-13 & 8,64E-14 \\ \cline{2-6} 
                                       & 5         & 2,87E-04 & 1,78E-06 & 1,37E-03 & 3,97E-04 \\ \cline{2-6} 
                                       & 10        & 5,25E+01 & 7,59E+00 & 2,73E+02 & 5,01E+01 \\ \cline{2-6} 
                                       & 20        & 9,26E+03 & 2,64E+03 & 2,25E+04 & 4,26E+03 \\ \cline{2-6} 
                                       & 25        & 1,92E+04 & 8,27E+03 & 3,62E+04 & 7,17E+03 \\ \cline{2-6} 
                                       & 50        & 1,37E+05 & 5,26E+04 & 3,16E+05 & 5,41E+04 \\ \cline{2-6} 
                                       & 100       & 6,68E+05 & 3,28E+05 & 1,45E+06 & 2,17E+05 \\ \cline{2-6} 
                                       & 200       & 2,93E+06 & 1,57E+06 & 5,90E+06 & 9,09E+05 \\ \cline{2-6} 
                                       & 500       & 2,19E+07 & 1,13E+07 & 3,73E+07 & 6,97E+06 \\ \hline
\multirow[t]{10}{*}{sphere}               & 1         & 6,04E-22 & 1,31E-27 & 9,75E-21 & 1,77E-21 \\ \cline{2-6} 
                                       & 2         & 2,20E-15 & 1,93E-18 & 3,63E-14 & 6,66E-15 \\ \cline{2-6} 
                                       & 5         & 1,34E-07 & 1,06E-09 & 8,73E-07 & 2,03E-07 \\ \cline{2-6} 
                                       & 10        & 2,05E-02 & 1,06E-03 & 7,32E-02 & 1,75E-02 \\ \cline{2-6} 
                                       & 20        & 1,23E+02 & 1,30E+01 & 6,63E+02 & 1,33E+02 \\ \cline{2-6} 
                                       & 25        & 5,84E+02 & 2,03E+02 & 1,85E+03 & 3,96E+02 \\ \cline{2-6} 
                                       & 50        & 3,87E+04 & 1,29E+04 & 9,92E+04 & 1,71E+04 \\ \cline{2-6} 
                                       & 100       & 2,54E+05 & 1,90E+05 & 2,88E+05 & 2,24E+04 \\ \cline{2-6} 
                                       & 200       & 5,72E+05 & 5,08E+05 & 5,99E+05 & 2,22E+04 \\ \cline{2-6} 
                                       & 500       & 1,52E+06 & 1,47E+06 & 1,56E+06 & 2,26E+04 \\ \hline
\multirow[t]{10}{*}{weierstrass}          & 1         & 3,46E-15 & 4,44E-16 & 1,18E-14 & 5,01E-15 \\ \cline{2-6} 
                                       & 2         & 6,62E-15 & 8,88E-16 & 2,35E-14 & 7,65E-15 \\ \cline{2-6} 
                                       & 5         & 2,90E-14 & 1,24E-14 & 5,86E-14 & 1,29E-14 \\ \cline{2-6} 
                                       & 10        & 5,92E-14 & 1,42E-14 & 8,17E-14 & 1,47E-14 \\ \cline{2-6} 
                                       & 20        & 9,24E-03 & 7,82E-14 & 2,77E-01 & 4,98E-02 \\ \cline{2-6} 
                                       & 25        & 4,76E-03 & 1,14E-13 & 1,43E-01 & 2,57E-02 \\ \cline{2-6} 
                                       & 50        & 3,65E-01 & 2,42E-13 & 6,58E+00 & 1,39E+00 \\ \cline{2-6} 
                                       & 100       & 1,13E-01 & 4,26E-13 & 1,53E+00 & 3,15E-01 \\ \cline{2-6} 
                                       & 200       & 5,15E+00 & 1,08E-12 & 5,43E+01 & 1,10E+01 \\ \cline{2-6} 
                                       & 500       & 2,43E+01 & 2,73E-12 & 9,38E+01 & 2,76E+01 \\ \hline
\end{longtable}

\begin{figure}[H]
\centering
\begin{tikzpicture}
  \begin{axis}[
    title={Hasil \textit{benchmarking} fungsi Ackley},
    legend entries={{KMA Best}, {KMA Worst}, {KMA Avg}, {EHO Best}, {EHO Worst}, {EHO Avg}, {PSO Best}, {PSO Worst}, {PSO Avg}},
    legend pos = outer north east,
    xlabel = Dimensi,
    ylabel = Nilai solusi,
    symbolic x coords={1,2,5,10,20,25,50,100,200,500},
    xtick=data,
    x tick label style={rotate=45, anchor=east},
    enlargelimits=0.05
    ]
    
    % KMA Best
    \addplot[blue,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/kma_ackley.tsv};
    
    % KMA Worst
    \addplot[green,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/kma_ackley.tsv};
    
    % KMA Avg
    \addplot[orange,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/kma_ackley.tsv};
    
    % EHO Best
    \addplot[red,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/eho_ackley.tsv};
    
    % EHO Worst
    \addplot[magenta,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/eho_ackley.tsv};
    
    % EHO Avg
    \addplot[cyan,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/eho_ackley.tsv};
    
    % PSO Best
    \addplot[lime,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/pso_ackley.tsv};
    
    % PSO Worst
    \addplot[pink,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/pso_ackley.tsv};
    
    % PSO Avg
    \addplot[orange,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/pso_ackley.tsv};
    
  \end{axis}
\end{tikzpicture}
\caption{Grafik hasil \textit{benchmarking} fungsi Ackley}
\label{fig:graph_ackley}
\end{figure}

Pada \cref{fig:graph_ackley} memperlihatkan hasil \textit{benchmarking} fungsi Ackley (multimodal) terhadap algoritma PSO, KMA, dan EHO pada berbagai dimensi. Hasil menunjukkan bahwa KMA memiliki performa paling stabil dan konsisten, dengan nilai solusi \textit{avg}, \textit{best}, dan \textit{worst} yang tetap rendah meskipun dimensi meningkat. EHO juga menunjukkan performa baik dan stabil, meskipun sedikit di bawah KMA. Sebaliknya, PSO mengalami penurunan performa signifikan pada dimensi tinggi, terlihat dari meningkatnya nilai \textit{avg} dan \textit{worst} secara drastis, yang mengindikasikan keterbatasannya dalam menangani fungsi multimodal berdimensi besar.

\begin{figure}[H]
\centering
\begin{tikzpicture}
  \begin{axis}[
    title={Hasil \textit{benchmarking} fungsi Discus},
    legend entries={{KMA Best}, {KMA Worst}, {KMA Avg}, {EHO Best}, {EHO Worst}, {EHO Avg}, {PSO Best}, {PSO Worst}, {PSO Avg}},
    legend pos = outer north east,
    xlabel = Dimensi,
    ylabel = Nilai solusi,
    symbolic x coords={1,2,5,10,20,25,50,100,200,500},
    xtick=data,
    x tick label style={rotate=45, anchor=east},
    enlargelimits=0.05
    ]
    
    % KMA Best
    \addplot[blue,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/kma_discus.tsv};
    
    % KMA Worst
    \addplot[green,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/kma_discus.tsv};
    
    % KMA Avg
    \addplot[orange,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/kma_discus.tsv};
    
    % EHO Best
    \addplot[red,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/eho_discus.tsv};
    
    % EHO Worst
    \addplot[magenta,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/eho_discus.tsv};
    
    % EHO Avg
    \addplot[cyan,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/eho_discus.tsv};
    
    % PSO Best
    \addplot[lime,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/pso_discus.tsv};
    
    % PSO Worst
    \addplot[pink,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/pso_discus.tsv};
    
    % PSO Avg
    \addplot[orange,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/pso_discus.tsv};
    
  \end{axis}
\end{tikzpicture}
\caption{Grafik hasil \textit{benchmarking} fungsi Discus}
\label{fig:graph_discus}
\end{figure}

Pada \cref{fig:graph_discus} menunjukkan hasil \textit{benchmarking} fungsi Discus terhadap algoritma KMA, EHO, dan PSO pada berbagai dimensi. Fungsi ini bersifat unimodal, sehingga idealnya algoritma harus mampu melakukan eksploitasi yang efisien. Dari grafik, terlihat bahwa KMA secara konsisten memberikan performa terbaik dan paling stabil di semua dimensi, dengan nilai solusi yang sangat rendah dan hampir tidak berubah. EHO juga menunjukkan performa yang baik dan sebanding dengan KMA. Sebaliknya, PSO mengalami penurunan performa signifikan saat dimensi meningkat, ditunjukkan oleh lonjakan drastis pada nilai solusi \textit{avg} dan \textit{worst}, khususnya setelah dimensi 50. Hal ini menandakan bahwa PSO kurang efektif dalam menjaga akurasi pada fungsi unimodal berdimensi tinggi, sementara KMA dan EHO terbukti lebih andal.

\begin{figure}[H]
\centering
\begin{tikzpicture}
  \begin{axis}[
    title={Hasil \textit{benchmarking} fungsi Griewank},
    legend entries={{KMA Best}, {KMA Worst}, {KMA Avg}, {EHO Best}, {EHO Worst}, {EHO Avg}, {PSO Best}, {PSO Worst}, {PSO Avg}},
    legend pos = outer north east,
    xlabel = Dimensi,
    ylabel = Nilai solusi,
    symbolic x coords={1,2,5,10,20,25,50,100,200,500},
    xtick=data,
    x tick label style={rotate=45, anchor=east},
    enlargelimits=0.05
    ]
    
    % KMA Best
    \addplot[blue,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/kma_griewank.tsv};
    
    % KMA Worst
    \addplot[green,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/kma_griewank.tsv};
    
    % KMA Avg
    \addplot[orange,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/kma_griewank.tsv};
    
    % EHO Best
    \addplot[red,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/eho_griewank.tsv};
    
    % EHO Worst
    \addplot[magenta,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/eho_griewank.tsv};
    
    % EHO Avg
    \addplot[cyan,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/eho_griewank.tsv};
    
    % PSO Best
    \addplot[lime,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/pso_griewank.tsv};
    
    % PSO Worst
    \addplot[pink,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/pso_griewank.tsv};
    
    % PSO Avg
    \addplot[orange,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/pso_griewank.tsv};
    
  \end{axis}
\end{tikzpicture}
\caption{Grafik hasil \textit{benchmarking} fungsi Griewank}
\label{fig:graph_griewank}
\end{figure}

Pada \cref{fig:graph_griewank} menampilkan hasil \textit{benchmarking} fungsi Griewank, yang merupakan fungsi multimodal, terhadap algoritma KMA, EHO, dan PSO pada berbagai dimensi. Hasil grafik menunjukkan bahwa KMA secara konsisten unggul di semua metrik (\textit{best}, \textit{worst}, \textit{avg}) bahkan hingga dimensi tinggi, dengan nilai solusi mendekati nol. EHO menunjukkan performa menengah, namun tetap stabil hingga dimensi 100 sebelum mengalami peningkatan nilai solusi. Di sisi lain, performa PSO memburuk seiring bertambahnya dimensi, dengan lonjakan tajam pada nilai \textit{avg} dan \textit{worst} mulai dari dimensi 100 ke atas. Hal ini menunjukkan bahwa KMA lebih efektif dalam menjelajahi \textit{landscape} kompleks dari fungsi multimodal seperti Griewank, dibandingkan dengan EHO dan PSO.

\begin{figure}[H]
\centering
\begin{tikzpicture}
  \begin{axis}[
    title={Hasil \textit{benchmarking} fungsi Schwefel 1.2 Problem},
    legend entries={{KMA Best}, {KMA Worst}, {KMA Avg}, {EHO Best}, {EHO Worst}, {EHO Avg}, {PSO Best}, {PSO Worst}, {PSO Avg}},
    legend pos = outer north east,
    xlabel = Dimensi,
    ylabel = Nilai solusi,
    symbolic x coords={1,2,5,10,20,25,50,100,200,500},
    xtick=data,
    x tick label style={rotate=45, anchor=east},
    enlargelimits=0.05
    ]
    
    % KMA Best
    \addplot[blue,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/kma_schwefel_1_2_problem.tsv};
    
    % KMA Worst
    \addplot[green,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/kma_schwefel_1_2_problem.tsv};
    
    % KMA Avg
    \addplot[orange,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/kma_schwefel_1_2_problem.tsv};
    
    % EHO Best
    \addplot[red,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/eho_schwefel_1_2_problem.tsv};
    
    % EHO Worst
    \addplot[magenta,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/eho_schwefel_1_2_problem.tsv};
    
    % EHO Avg
    \addplot[cyan,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/eho_schwefel_1_2_problem.tsv};
    
    % PSO Best
    \addplot[lime,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/pso_schwefel_1_2_problem.tsv};
    
    % PSO Worst
    \addplot[pink,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/pso_schwefel_1_2_problem.tsv};
    
    % PSO Avg
    \addplot[orange,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/pso_schwefel_1_2_problem.tsv};
    
  \end{axis}
\end{tikzpicture}
\caption{Grafik hasil \textit{benchmarking} fungsi Schwefel 1.2 Problem}
\label{fig:graph_schwefel_1_2}
\end{figure}

Pada \cref{fig:graph_schwefel_1_2} menunjukkan hasil benchmarking fungsi Schwefel 1.2, yang merupakan fungsi unimodal, terhadap algoritma KMA, EHO, dan PSO pada berbagai dimensi. Dari grafik terlihat bahwa KMA kembali menunjukkan performa paling stabil dan akurat di seluruh dimensi, dengan nilai solusi \textit{best}, \textit{avg}, dan \textit{worst} yang tetap sangat rendah. EHO juga menunjukkan hasil yang serupa dengan KMA, meskipun sedikit lebih fluktuatif di beberapa titik. Sementara itu, PSO mengalami degradasi performa tajam mulai dari dimensi 100, dengan lonjakan besar pada nilai solusi \textit{avg} dan \textit{worst}, yang menandakan ketidakstabilan PSO dalam menyelesaikan fungsi unimodal berdimensi tinggi. Hal ini memperkuat kesimpulan bahwa KMA dan EHO lebih andal dibanding PSO untuk optimasi fungsi-fungsi eksploitasi seperti Schwefel 1.2 problem.

\begin{figure}[H]
\centering
\begin{tikzpicture}
  \begin{axis}[
    title={Hasil \textit{benchmarking} fungsi Sphere},
    legend entries={{KMA Best}, {KMA Worst}, {KMA Avg}, {EHO Best}, {EHO Worst}, {EHO Avg}, {PSO Best}, {PSO Worst}, {PSO Avg}},
    legend pos = outer north east,
    xlabel = Dimensi,
    ylabel = Nilai solusi,
    symbolic x coords={1,2,5,10,20,25,50,100,200,500},
    xtick=data,
    x tick label style={rotate=45, anchor=east},
    enlargelimits=0.05
    ]
    
    % KMA Best
    \addplot[blue,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/kma_sphere.tsv};
    
    % KMA Worst
    \addplot[green,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/kma_sphere.tsv};
    
    % KMA Avg
    \addplot[orange,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/kma_sphere.tsv};
    
    % EHO Best
    \addplot[red,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/eho_sphere.tsv};
    
    % EHO Worst
    \addplot[magenta,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/eho_sphere.tsv};
    
    % EHO Avg
    \addplot[cyan,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/eho_sphere.tsv};
    
    % PSO Best
    \addplot[lime,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/pso_sphere.tsv};
    
    % PSO Worst
    \addplot[pink,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/pso_sphere.tsv};
    
    % PSO Avg
    \addplot[orange,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/pso_sphere.tsv};
    
  \end{axis}
\end{tikzpicture}
\caption{Grafik hasil \textit{benchmarking} fungsi Sphere}
\label{fig:graph_sphere}
\end{figure}

Pada \cref{fig:graph_sphere} memperlihatkan hasil benchmarking fungsi Sphere, yang merupakan fungsi unimodal, terhadap algoritma KMA, EHO, dan PSO. Terlihat bahwa KMA memiliki performa paling konsisten dan optimal di seluruh dimensi, dengan nilai solusi \textit{best}, \textit{avg}, dan \textit{worst} yang tetap rendah bahkan saat dimensi meningkat hingga 500. EHO juga menunjukkan kinerja serupa dengan KMA, walaupun sedikit lebih bervariasi. Sebaliknya, PSO mengalami penurunan performa yang signifikan seiring bertambahnya dimensi, dengan lonjakan tajam pada nilai solusi, terutama nilai \textit{worst} dan \textit{avg}. Hal ini mengindikasikan bahwa KMA dan EHO lebih efisien dalam menyelesaikan fungsi-fungsi eksploitasi seperti Sphere, sementara PSO kurang stabil dalam skenario berdimensi tinggi.

\begin{figure}[H]
\centering
\begin{tikzpicture}
  \begin{axis}[
    title={Hasil \textit{benchmarking} fungsi Weierstrass},
    legend entries={{KMA Best}, {KMA Worst}, {KMA Avg}, {EHO Best}, {EHO Worst}, {EHO Avg}, {PSO Best}, {PSO Worst}, {PSO Avg}},
    legend pos = outer north east,
    xlabel = Dimensi,
    ylabel = Nilai solusi,
    symbolic x coords={1,2,5,10,20,25,50,100,200,500},
    xtick=data,
    x tick label style={rotate=45, anchor=east},
    enlargelimits=0.05
    ]
    
    % KMA Best
    \addplot[blue,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/kma_weierstrass.tsv};
    
    % KMA Worst
    \addplot[green,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/kma_weierstrass.tsv};
    
    % KMA Avg
    \addplot[orange,mark=diamond*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/kma_weierstrass.tsv};
    
    % EHO Best
    \addplot[red,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/eho_weierstrass.tsv};
    
    % EHO Worst
    \addplot[magenta,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/eho_weierstrass.tsv};
    
    % EHO Avg
    \addplot[cyan,mark=square*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/eho_weierstrass.tsv};
    
    % PSO Best
    \addplot[lime,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=3,
    ] {data/pso_weierstrass.tsv};
    
    % PSO Worst
    \addplot[pink,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=4,
    ] {data/pso_weierstrass.tsv};
    
    % PSO Avg
    \addplot[orange,mark=triangle*] table[
      col sep=tab,
      skip first n=1,
      x index=1,
      y index=2,
    ] {data/pso_weierstrass.tsv};
    
  \end{axis}
\end{tikzpicture}
\caption{Grafik hasil \textit{benchmarking} fungsi Weierstrass}
\label{fig:graph_weierstrass}
\end{figure}

Pada \cref{fig:graph_weierstrass} menunjukkan bahwa pada fungsi Weierstrass, performa algoritma PSO jauh lebih stabil dan unggul dibanding KMA dan EHO, terutama pada dimensi tinggi, di mana PSO mempertahankan nilai solusi yang sangat rendah. Sebaliknya, performa EHO dan KMA menurun tajam seiring bertambahnya dimensi, dengan nilai \textit{avg} dan \textit{worst} yang melonjak signifikan, khususnya untuk EHO yang mencatat nilai solusi tertinggi pada dimensi 500. Hal ini menunjukkan bahwa PSO lebih handal dalam menghadapi kompleksitas fungsi multimodal seperti Weierstrass, sementara KMA dan EHO kurang stabil dalam kondisi berdimensi besar.

\begin{longtable}[c]{|p{3.5cm}|l|l|l|l|l|}
\caption{rangkuman hasil \textit{benchmarking}}
\label{tab:summary-result}\\
\hline
function                               & dimension & avg & best & worst & std \\ \hline
\endfirsthead
%
\endhead
%
\multirow[t]{10}{*}{ackley}               & 1         & PSO & KMA  & PSO   & PSO \\ \cline{2-6} 
                                       & 2         & PSO & PSO  & PSO   & PSO \\ \cline{2-6} 
                                       & 5         & PSO & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 10        & EHO & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 20        & EHO & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 25        & EHO & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 50        & EHO & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 100       & EHO & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 200       & EHO & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 500       & EHO & KMA  & EHO   & PSO \\ \hline
\multirow[t]{10}{*}{discus}               & 1         & PSO & PSO  & PSO   & PSO \\ \cline{2-6} 
                                       & 2         & EHO & PSO  & PSO   & PSO \\ \cline{2-6} 
                                       & 5         & PSO & PSO  & PSO   & PSO \\ \cline{2-6} 
                                       & 10        & EHO & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 20        & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 25        & EHO & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 50        & KMA & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 100       & EHO & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 200       & KMA & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 500       & KMA & KMA  & EHO   & EHO \\ \hline
\multirow[t]{10}{*}{griewank}             & 1         & PSO & seri & PSO   & PSO \\ \cline{2-6} 
                                       & 2         & PSO & PSO  & PSO   & PSO \\ \cline{2-6} 
                                       & 5         & EHO & KMA  & PSO   & PSO \\ \cline{2-6} 
                                       & 10        & EHO & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 20        & EHO & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 25        & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 50        & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 100       & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 200       & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 500       & KMA & KMA  & KMA   & KMA \\ \hline
\multirow[t]{10}{*}{schwefel 1.2 problem} & 1         & PSO & KMA  & PSO   & PSO \\ \cline{2-6} 
                                       & 2         & PSO & PSO  & PSO   & PSO \\ \cline{2-6} 
                                       & 5         & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 10        & EHO & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 20        & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 25        & KMA & KMA  & EHO   & KMA \\ \cline{2-6} 
                                       & 50        & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 100       & KMA & KMA  & EHO   & KMA \\ \cline{2-6} 
                                       & 200       & EHO & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 500       & KMA & KMA  & EHO   & KMA \\ \hline
\multirow[t]{10}{*}{sphere}               & 1         & PSO & KMA  & PSO   & PSO \\ \cline{2-6} 
                                       & 2         & PSO & PSO  & PSO   & PSO \\ \cline{2-6} 
                                       & 5         & PSO & KMA  & PSO   & PSO \\ \cline{2-6} 
                                       & 10        & KMA & KMA  & EHO   & EHO \\ \cline{2-6} 
                                       & 20        & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 25        & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 50        & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 100       & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 200       & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 500       & KMA & KMA  & KMA   & KMA \\ \hline
\multirow[t]{10}{*}{weierstrass}          & 1         & PSO & KMA  & PSO   & PSO \\ \cline{2-6} 
                                       & 2         & PSO & KMA  & PSO   & PSO \\ \cline{2-6} 
                                       & 5         & PSO & KMA  & PSO   & PSO \\ \cline{2-6} 
                                       & 10        & PSO & KMA  & PSO   & PSO \\ \cline{2-6} 
                                       & 20        & PSO & KMA  & PSO   & PSO \\ \cline{2-6} 
                                       & 25        & PSO & KMA  & PSO   & PSO \\ \cline{2-6} 
                                       & 50        & PSO & KMA  & PSO   & PSO \\ \cline{2-6} 
                                       & 100       & PSO & KMA  & PSO   & PSO \\ \cline{2-6} 
                                       & 200       & KMA & KMA  & KMA   & KMA \\ \cline{2-6} 
                                       & 500       & KMA & KMA  & KMA   & KMA \\ \hline
\end{longtable}

\section{Pengujian}
\subsection{\textit{Unit test}}
Validasi keakuratan fungsi-fungsi \textit{benchmark} yang telah dikumpulkan menjadi prioritas utama melalui penerapan \textit{unit testing} yang menyeluruh dan terstruktur. Proses pengujian unit ini secara khusus difokuskan untuk memastikan bahwa setiap fungsi \textit{benchmark} mampu menghasilkan hasil komputasi yang sesuai dengan spesifikasi teoretis dan standar yang telah ditetapkan. Rangkaian tes mencakup evaluasi mendalam terhadap konsistensi \textit{output} fungsi pada berbagai skenario \textit{input}, kemampuan adaptasi terhadap perubahan dimensi masalah, ketahanan fungsi terhadap transformasi geometris seperti \textit{rotation} dan \textit{shift}, serta stabilitas perhitungan pada kondisi parameter bias yang beragam. Implementasi \textit{unit testing} ini berfungsi sebagai mekanisme kontrol kualitas yang esensial untuk mengidentifikasi dan mengeliminasi potensi anomali, kesalahan implementasi, atau ketidakkonsistenan dalam perilaku fungsi sebelum digunakan sebagai standar evaluasi algoritma optimasi. Dengan demikian, \textit{unit testing} tidak hanya menjamin reliabilitas teknis dari setiap fungsi \textit{benchmark}, tetapi juga membangun kepercayaan terhadap validitas hasil pengujian algoritma yang akan dilakukan menggunakan CECO.

\textit{Method setup} berfungsi untuk menginisialisasi properti yang akan digunakan pada \textit{test case}. Properti yang diinisialisasi yaitu seperti dimensi untuk fungsi CEC dan COCO, rotasi, \textit{shift}, \textit{bias} untuk fungsi CEC seperti pada \cref{lst:setup_test_case_cec}, dan \textit{seed} untuk fungsi COCO pada \cref{lst:setup_test_case_coco}
\begin{lstlisting}[language=Python, caption=\textit{setup unit test} fungsi CEC, label=lst:setup_test_case_cec]
    def setUp(self):
        # Example rotation matrix and shift vector for testing
        # Identity matrix (no rotation)
        self.rotation_identity = np.eye(2)
        self.rotation_non_identity = np.array([[0, -1], [1, 0]])
        self.shift = np.array([1, 1])
        self.no_shift = np.zeros(2)
        self.f_bias = 1.0
        self.dimension = 2
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=\textit{setup unit test} fungsi COCO, label=lst:setup_test_case_coco]
    def setUp(self):
        np.random.seed(42)
\end{lstlisting}
\textit{Test case} yang dirancang mencakup berbagai skenario untuk menguji fungsi benchmark dalam kondisi yang beragam. Setiap \textit{test case} mengevaluasi aspek spesifik dari fungsi untuk memastikan perilaku yang konsisten dan akurat.

Pengujian tanpa transformasi ditunjukkan pada \textit{test case} pertama (\cref{lst:no_shift_no_rotation}) yang menggunakan matriks rotasi identitas dan tanpa \textit{shift}. Pada \cref{lst:no_shift_no_rotation} menguji fungsi Sphere dengan \textit{input} $[3.0, 2.0]$ dan memverifikasi bahwa hasil evaluasi sesuai dengan perhitungan manual yaitu 13.0. \textit{Test case} ini memastikan fungsi bekerja dengan benar dalam kondisi paling sederhana tanpa transformasi apapun.
\begin{lstlisting}[language=Python, caption=\textit{Test case} tanpa rotasi dan \textit{shift}, label=lst:no_shift_no_rotation]
    def test_evaluate_with_identity_rotation_and_no_shift(self):
        sphere = Sphere(self.dimension, self.rotation_identity, self.no_shift)
        input_vector = np.array([3.0, 2.0])
        result = sphere.evaluate(input_vector)
        expected_result = 13.0
        self.assertAlmostEqual(result, expected_result, places=5)
\end{lstlisting}
Pengujian dengan transformasi lengkap didemonstrasikan pada \textit{test case} kedua (\cref{lst:shift_rotation}) yang menerapkan rotasi non-identitas dan \textit{shift}. Menggunakan \textit{input} yang sama $[3.0, 2.0]$, \textit{test case} ini memverifikasi bahwa transformasi rotasi dan \textit{shift} berfungsi dengan benar dengan hasil yang diharapkan 5.0. Ini menguji kemampuan fungsi dalam menangani transformasi ruang pencarian yang kompleks.
\begin{lstlisting}[language=Python, caption=\textit{Test case} dengan rotasi dan \textit{shift}, label=lst:shift_rotation]
    def test_evaluate_with_non_identity_rotation_and_shift(self):
        sphere = Sphere(self.dimension, self.rotation_non_identity, self.shift)
        input_vector = np.array([3.0, 2.0])
        result = sphere.evaluate(input_vector)
        expected_result = 5.0
        self.assertAlmostEqual(result, expected_result, places=5)
\end{lstlisting}
\textit{Test case} untuk bias mengevaluasi pengaruh parameter $f_{\text{bias}}$ terhadap hasil akhir fungsi. Dengan menggunakan \textit{input} vector nol dan menambahkan nilai bias, \textit{test case} ini memastikan bahwa bias diterapkan dengan benar sebagai konstanta additif pada hasil evaluasi fungsi.
\begin{lstlisting}[language=Python, caption=\textit{Test case} dengan \textit{bias}, label=lst:bias]
    def test_evaluate_with_f_bias(self):
        sphere = Sphere(self.dimension, self.rotation_identity,
                        self.no_shift, self.f_bias)
        input_vector = np.zeros(2)
        result = sphere.evaluate(input_vector)
        expected_result = 0.0 + self.f_bias
        self.assertAlmostEqual(result, expected_result, places=5)
\end{lstlisting}
Pengujian dengan input khusus mencakup dua skenario: input bernilai nol (\cref{lst:nol}) dan input bernilai negatif (\cref{lst:negative}). \textit{Test case} untuk input nol menggunakan fungsi Attractive sector yang lebih kompleks dengan transformasi multi-tahap meliputi matriks $Q$, diagonal matrix ($\Lambda^{\alpha}$), dan matriks $R$, diikuti dengan transformasi $T_{\text{osz}}$ dan penambahan $f_{\text{bias}}$. Test case untuk input negatif menggunakan skenario serupa dengan \textit{input} $[-3, -2]$ untuk memastikan fungsi dapat menangani nilai negatif dengan benar. Kedua \textit{test case} ini menghitung hasil yang diharapkan secara manual dan membandingkannya dengan output fungsi untuk memverifikasi akurasi implementasi.
\begin{lstlisting}[language=Python, caption=\textit{Test case} dengan input bernilai nol, label=lst:nol]
    def test_evaluate_at_zero_vector(self):
        """
        Test the evaluate method at the zero vector.
        """
        dimension = 2
        test_func = Attractive_sector(dimension)
        benchmark = Benchmark(dimension)

        # Zero vector
        input_vector = np.zeros(dimension)
        result = test_func.evaluate(input_vector)

        # Manually compute the expected result
        z = test_func.Q @ test_func.diag_matrix @ test_func.R @ (
            input_vector - test_func.x_opt)
        s = np.where((z * test_func.x_opt), 10 ** 2, 1)

        expected_result = np.sum((s * z) ** 2)
        expected_result = benchmark.T_osz(
            expected_result ** 0.9) + test_func.f_opt

        self.assertAlmostEqual(result, expected_result, places=6)
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=\textit{Test case} dengan input bernilai negatif, label=lst:negative]
    def test_evaluate_with_negative_values(self):
        dimension = 2
        test_func = Attractive_sector(dimension)
        benchmark = Benchmark(dimension)

        # Input vector with negative values
        input_vector = np.array([-3, -2])
        result = test_func.evaluate(input_vector)

        # Manually compute the expected result
        z = test_func.Q @ test_func.diag_matrix @ test_func.R @ (
            input_vector - test_func.x_opt)
        s = np.where((z * test_func.x_opt), 10 ** 2, 1)

        expected_result = np.sum((s * z) ** 2)
        expected_result = benchmark.T_osz(
            expected_result ** 0.9) + test_func.f_opt

        self.assertAlmostEqual(result, expected_result, places=6)
\end{lstlisting}

\subsection{\textit{Compability test}}
Setelah seluruh fungsi diuji secara individual melalui \textit{unit test}, tahap berikutnya adalah pengujian kompatibilitas \textit{library} CECO terhadap berbagai versi Python dan NumPy. Tujuannya adalah memastikan bahwa \textit{library} dapat berjalan stabil dan konsisten di berbagai konfigurasi sistem yang umum digunakan oleh pengguna.

Untuk mendukung proses ini, digunakan Docker sebagai \textit{platform} utama pengujian. Docker memungkinkan pembuatan lingkungan terisolasi (\textit{container}) yang dapat dikonfigurasi dengan versi Python dan NumPy tertentu tanpa mengganggu sistem utama. Pendekatan ini tidak hanya mengurangi risiko konflik dependensi, tetapi juga mempercepat proses pengujian karena versi lingkungan dapat diatur secara fleksibel dan otomatis.

Pada \cref{lst:dockerfile} baris ke 1-2 menentukan \textit{base image} yang digunakan. Dengan menggunakan argumen BASE\_IMAGE, pengujian bisa dilakukan pada berbagai versi python, seperti python:3.6, python:3.8, python:3.10, dan versi lainnya. Pada \cref{lst:dockerfile} baris ke 4 merupakan perintah yang memastikan bahwa \textit{tools} penting untuk kompilasi dan instalasi tersedia di dalam kontainer. Pada \cref{lst:dockerfile} baris ke 6-8 akan menyalin seluruh isi direktori proyek ke dalam direktori kerja kontainer, yakni /app. Pada \cref{lst:dockerfile} baris ke 10-11 akan menggunakan argumen NUMPY\_VERSION untuk menginstal versi numpy tertentu, misalnya numpy==1.19.0 atau numpy==2.2, sesuai dengan konfigurasi pengujian. Pada \cref{lst:dockerfile} baris ke 13 akan menginstal \textit{library} CECO dalam mode \textit{editable}, sehingga perubahan lokal pada kode dapat langsung diuji. Pada \cref{lst:dockerfile} baris ke 15 akan mengeksekusi skrip pengujian \textit{unit test} setelah \textit{environment} siap.
\lstinputlisting[caption=kode docker file, label=lst:dockerfile]{kode/dockerfile}

Untuk mem\textit{build} dan menjalankan dockerfile tersebut digunakan perintah pada \textit{terminal} dengan \cref{lst:docker_build}. Pada \cref{lst:docker_build} baris pertama membuat \textit{image} baru bernama ceco-test:py39-np22 dengan python 3.9 dan numpy versi 2.2. Pada \cref{lst:docker_build} baris kedua menjalankan container berdasarkan \textit{image} yang telah dibuat, secara otomatis menjalankan pengujian pada lingkungan yang telah dikonfigurasi.

\begin{lstlisting}[caption=Perintah untuk build dockerfile dan menjalankan container hasil build, label=lst:docker_build]
docker build --build-arg BASE_IMAGE=python:3.9 --build-arg NUMPY_VERSION="numpy==2.2" -t ceco-test:py39-np22 .
docker run ceco-test:py39-np22
\end{lstlisting}


Dengan menjalankan variasi \textit{build} semacam ini untuk berbagai kombinasi versi python dan numPy, pengembang dapat dengan cepat mengidentifikasi versi minimum yang didukung, serta memastikan tidak terjadi regresi pada versi-versi terbaru. Berdasarkan hasil pengujian ini, diketahui bahwa \textit{library} CECO kompatibel mulai dari Python 3.6 dan NumPy 1.19.0, informasi yang kemudian disertakan dalam dokumentasi resmi sebagai acuan pengguna.